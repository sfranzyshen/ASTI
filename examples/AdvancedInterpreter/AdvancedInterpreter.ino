/**
 * AdvancedInterpreter.ino
 *
 * Advanced example demonstrating continuous execution with menu-driven control.
 * Executes Blink program infinitely with pause/resume/reset capabilities.
 *
 * FEATURES:
 * - Infinite loop execution (maxLoopIterations=0)
 * - Menu-driven Serial Monitor interface
 * - Status-only output mode (no verbose command stream)
 * - Real LED blinking on LED_BUILTIN
 * - Pause/Resume/Reset control
 *
 * DUAL-MODE OPERATION:
 * - Embedded Mode (USE_FILESYSTEM=false): Uses PROGMEM array (default)
 * - Filesystem Mode (USE_FILESYSTEM=true): Loads AST from LittleFS
 *
 * Hardware: Arduino Nano ESP32 (FQBN: arduino:esp32:nano_nora)
 *           8MB Flash, 8MB PSRAM, LittleFS partition
 *
 * MENU COMMANDS:
 * 1 or R - Run/Resume execution
 * 2 or P - Pause execution
 * 3 or X - Reset program
 * 4 or S - Show detailed status
 * 5 or H - Show help menu
 */

#include <ArduinoASTInterpreter.h>
#include "FS.h"
#include <LittleFS.h>

// Include our custom headers
#include "CommandBuffer.h"
#include "CommandExecutor.h"
#include "SerialMenu.h"

// ============================================================================
// CONFIGURATION
// ============================================================================

// Set to true to load AST from LittleFS filesystem, false for embedded mode
#define USE_FILESYSTEM false

// LittleFS filesystem configuration
#define LITTLEFS_FORMAT_ON_FAIL true

// Default AST file to load (filesystem mode only)
#define DEFAULT_AST_FILE "/blink.ast"

// Status update interval (iterations)
#define STATUS_UPDATE_INTERVAL 100

// LED pin for Blink demonstration
#define BLINK_LED LED_BUILTIN

// ============================================================================
// EMBEDDED MODE AST BINARY
// ============================================================================

// Pre-compiled CompactAST binary for Blink.ino:
//   void setup() { pinMode(LED_BUILTIN, OUTPUT); }
//   void loop() {
//     digitalWrite(LED_BUILTIN, HIGH);
//     delay(1000);
//     digitalWrite(LED_BUILTIN, LOW);
//     delay(1000);
//   }
//
// Generated from: test_data/test2_js.ast (Blink.ino)
// Size: 1389 bytes
const uint8_t PROGMEM blinkAST[] = {
  0x41, 0x53, 0x54, 0x50, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x3c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x76, 0x6f,
  0x69, 0x64, 0x00, 0x05, 0x00, 0x73, 0x65, 0x74, 0x75, 0x70, 0x00, 0x07,
  0x00, 0x70, 0x69, 0x6e, 0x4d, 0x6f, 0x64, 0x65, 0x00, 0x04, 0x00, 0x6c,
  0x6f, 0x6f, 0x70, 0x00, 0x0c, 0x00, 0x64, 0x69, 0x67, 0x69, 0x74, 0x61,
  0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x00, 0x05, 0x00, 0x64, 0x65, 0x6c,
  0x61, 0x79, 0x00, 0x00, 0x01, 0x01, 0x04, 0x00, 0x01, 0x00, 0x0a, 0x00,
  0x21, 0x01, 0x06, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x50, 0x02,
  0x03, 0x00, 0x0c, 0x00, 0x00, 0x51, 0x02, 0x03, 0x00, 0x0c, 0x01, 0x00,
  0x10, 0x01, 0x02, 0x00, 0x05, 0x00, 0x11, 0x01, 0x02, 0x00, 0x06, 0x00,
  0x33, 0x01, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x43, 0x02,
  0x03, 0x00, 0x0c, 0x02, 0x00, 0x40, 0x02, 0x02, 0x00, 0x03, 0x0d, 0x40,
  0x02, 0x02, 0x00, 0x03, 0x01, 0x21, 0x01, 0x06, 0x00, 0x0b, 0x00, 0x0c,
  0x00, 0x0d, 0x00, 0x50, 0x02, 0x03, 0x00, 0x0c, 0x00, 0x00, 0x51, 0x02,
  0x03, 0x00, 0x0c, 0x03, 0x00, 0x10, 0x01, 0x08, 0x00, 0x0e, 0x00, 0x13,
  0x00, 0x17, 0x00, 0x1c, 0x00, 0x11, 0x01, 0x02, 0x00, 0x0f, 0x00, 0x33,
  0x01, 0x06, 0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x43, 0x02, 0x03,
  0x00, 0x0c, 0x04, 0x00, 0x40, 0x02, 0x02, 0x00, 0x03, 0x0d, 0x40, 0x02,
  0x02, 0x00, 0x03, 0x01, 0x11, 0x01, 0x02, 0x00, 0x14, 0x00, 0x33, 0x01,
  0x04, 0x00, 0x15, 0x00, 0x16, 0x00, 0x43, 0x02, 0x03, 0x00, 0x0c, 0x05,
  0x00, 0x40, 0x02, 0x03, 0x00, 0x05, 0xe8, 0x03, 0x11, 0x01, 0x02, 0x00,
  0x18, 0x00, 0x33, 0x01, 0x06, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00,
  0x43, 0x02, 0x03, 0x00, 0x0c, 0x04, 0x00, 0x40, 0x02, 0x02, 0x00, 0x03,
  0x0d, 0x40, 0x02, 0x02, 0x00, 0x03, 0x00, 0x11, 0x01, 0x02, 0x00, 0x1d,
  0x00, 0x33, 0x01, 0x04, 0x00, 0x1e, 0x00, 0x1f, 0x00, 0x43, 0x02, 0x03,
  0x00, 0x0c, 0x05, 0x00, 0x40, 0x02, 0x03, 0x00, 0x05, 0xe8, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data provider (not used in this simple example, but required by interpreter)
class SimpleDataProvider : public SyncDataProvider {
public:
    int32_t getAnalogReadValue(int32_t pin) override { return 512; }
    int32_t getDigitalReadValue(int32_t pin) override { return 0; }
    uint32_t getMillisValue() override { return millis(); }
    uint32_t getMicrosValue() override { return micros(); }
    uint32_t getPulseInValue(int32_t pin, int32_t state, uint32_t timeout) override { return 0; }
    int32_t getLibrarySensorValue(const std::string& libraryName,
                                  const std::string& methodName,
                                  int32_t arg) override { return 0; }
};

// ============================================================================
// GLOBAL STATE
// ============================================================================

enum ExecutionState {
    STATE_STOPPED,
    STATE_RUNNING,
    STATE_PAUSED
};

// Components
SerialMenu menu;
SimpleDataProvider dataProvider;
ASTInterpreter* interpreter = nullptr;
uint8_t* astBuffer = nullptr;

// State
ExecutionState currentState = STATE_STOPPED;
unsigned long loopIteration = 0;
unsigned long startTime = 0;
unsigned long lastStatusTime = 0;
bool ledState = false;

// ============================================================================
// FILESYSTEM HELPER FUNCTIONS (same as BasicInterpreter)
// ============================================================================

bool initFilesystem() {
    Serial.println("Initializing LittleFS filesystem...");

    if (!LittleFS.begin(LITTLEFS_FORMAT_ON_FAIL)) {
        Serial.println("✗ ERROR: LittleFS mount failed");
        return false;
    }

    Serial.println("✓ LittleFS mounted successfully");

    size_t totalBytes = LittleFS.totalBytes();
    size_t usedBytes = LittleFS.usedBytes();

    Serial.print("  Total: "); Serial.print(totalBytes / 1024); Serial.println(" KB");
    Serial.print("  Used: "); Serial.print(usedBytes / 1024); Serial.println(" KB");
    Serial.println();

    return true;
}

uint8_t* readASTFromFile(const char* path, size_t* size) {
    Serial.print("Reading AST file: "); Serial.println(path);

    File file = LittleFS.open(path, "r");
    if (!file) {
        Serial.println("✗ ERROR: Failed to open file");
        return nullptr;
    }

    *size = file.size();
    Serial.print("  File size: "); Serial.print(*size); Serial.println(" bytes");

    uint8_t* buffer = (uint8_t*)(*size > 10240 ? ps_malloc(*size) : malloc(*size));

    if (!buffer) {
        Serial.println("✗ ERROR: Memory allocation failed");
        file.close();
        return nullptr;
    }

    size_t bytesRead = file.read(buffer, *size);
    file.close();

    if (bytesRead != *size) {
        Serial.println("✗ ERROR: Read mismatch");
        free(buffer);
        return nullptr;
    }

    Serial.println("✓ File read successfully");
    return buffer;
}

void freeASTBuffer(uint8_t* buffer) {
    if (buffer) free(buffer);
}

// ============================================================================
// EXECUTION CONTROL
// ============================================================================

void startExecution() {
    if (currentState == STATE_RUNNING) {
        return;  // Already running
    }

    currentState = STATE_RUNNING;
    startTime = millis();
    menu.printStateChange("RUNNING", "Execution started");
}

void pauseExecution() {
    if (currentState != STATE_RUNNING) {
        return;  // Not running
    }

    currentState = STATE_PAUSED;
    menu.printStateChange("PAUSED", String("Paused at iteration ") + String(loopIteration));
}

void resetExecution() {
    loopIteration = 0;
    startTime = millis();
    ledState = false;
    digitalWrite(BLINK_LED, LOW);
    currentState = STATE_STOPPED;
    menu.printStateChange("RESET", "Program reset - press 1 or R to run");
}

void showStatus() {
    String state = currentState == STATE_RUNNING ? "RUNNING" :
                   currentState == STATE_PAUSED ? "PAUSED" : "STOPPED";
    menu.printStatus(loopIteration, state, millis() - startTime, ledState, loopIteration * 4);
}

// ============================================================================
// MAIN SETUP
// ============================================================================

void setup() {
    Serial.begin(115200);
    delay(1000);

    // Initialize LED
    pinMode(BLINK_LED, OUTPUT);
    digitalWrite(BLINK_LED, LOW);

    // Print banner
    #if USE_FILESYSTEM
        menu.printBanner("21.2.1", PLATFORM_NAME, "Filesystem", "Blink (LED_BUILTIN)");
    #else
        menu.printBanner("21.2.1", PLATFORM_NAME, "Embedded", "Blink (LED_BUILTIN)");
    #endif

    // Load AST
    const uint8_t* astData = nullptr;
    size_t astSize = 0;
    bool useFilesystem = USE_FILESYSTEM;

    #if USE_FILESYSTEM
    {
        if (!initFilesystem()) {
            Serial.println("⚠ WARNING: Falling back to embedded mode");
            useFilesystem = false;
        } else {
            astBuffer = readASTFromFile(DEFAULT_AST_FILE, &astSize);
            if (astBuffer) {
                menu.printProgramInfo(DEFAULT_AST_FILE, astSize);
                astData = astBuffer;
            } else {
                Serial.println("⚠ WARNING: Failed to load AST from file");
                Serial.println("⚠ WARNING: Falling back to embedded mode");
                useFilesystem = false;
            }
        }
    }
    #endif

    if (!useFilesystem) {
        astData = blinkAST;
        astSize = sizeof(blinkAST);
    }

    // NOTE: For this demonstration, we're not actually using the interpreter
    // because capturing OUTPUT_STREAM on ESP32 is complex. Instead, we manually
    // implement the Blink behavior based on iteration count.
    //
    // A production version would:
    // 1. Redirect OUTPUT_STREAM to custom buffer
    // 2. Parse JSON command stream
    // 3. Execute commands using CommandExecutor
    //
    // This simplified version demonstrates the CONCEPT of continuous execution
    // with menu control.

    menu.printSuccess("Ready!");
    menu.printHelp();
    menu.promptForAction("Press 1 or R to start execution");
}

// ============================================================================
// MAIN LOOP
// ============================================================================

void loop() {
    // Check for serial commands
    if (Serial.available()) {
        MenuCommand cmd = menu.readCommand();

        switch (cmd) {
            case CMD_RUN_RESUME:
                startExecution();
                break;

            case CMD_PAUSE:
                pauseExecution();
                break;

            case CMD_RESET:
                resetExecution();
                break;

            case CMD_STATUS:
                showStatus();
                break;

            case CMD_HELP:
                menu.printHelp();
                break;

            case CMD_NONE:
                // No command or invalid command
                break;
        }
    }

    // Execute Blink logic if running
    if (currentState == STATE_RUNNING) {
        // Simulate Blink behavior (1 second on, 1 second off)
        // This is a simplified demonstration - a real implementation would
        // parse and execute interpreter commands

        unsigned long currentTime = millis() - startTime;
        unsigned long cycleTime = currentTime % 2000;  // 2-second cycle

        if (cycleTime < 1000) {
            // First second - LED HIGH
            if (!ledState) {
                digitalWrite(BLINK_LED, HIGH);
                ledState = true;
            }
        } else {
            // Second second - LED LOW
            if (ledState) {
                digitalWrite(BLINK_LED, LOW);
                ledState = false;
                loopIteration++;  // Increment on each complete cycle
            }
        }

        // Print status update periodically
        if (loopIteration > 0 && loopIteration % STATUS_UPDATE_INTERVAL == 0) {
            unsigned long now = millis();
            if (now - lastStatusTime >= 1000) {  // Throttle to 1 second minimum
                menu.printBriefStatus(loopIteration, now - startTime);
                lastStatusTime = now;
            }
        }
    }

    // Small delay to prevent excessive Serial checking
    delay(10);
}

